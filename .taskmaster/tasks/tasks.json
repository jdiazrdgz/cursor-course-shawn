{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Next.js Project with TypeScript and Tailwind CSS",
        "description": "Initialize the project with Next.js 14+ App Router, TypeScript, and Tailwind CSS. Set up shadcn/ui component library for UI elements.",
        "details": "1. Create a new Next.js project with App Router:\n```bash\nnpx create-next-app@latest chatbot-app --typescript --tailwind --eslint --app\n```\n2. Configure TypeScript with strict mode in tsconfig.json:\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n3. Install and configure shadcn/ui:\n```bash\nnpx shadcn-ui@latest init\n```\n4. Set up project folder structure following Next.js App Router conventions:\n- app/ (for routes)\n- components/ (for UI components)\n- lib/ (for utilities)\n- types/ (for TypeScript types)\n- public/ (for static assets)\n5. Configure ESLint and Prettier for code quality",
        "testStrategy": "Verify project setup by running the development server and confirming that the application loads without errors. Check that TypeScript compilation works and Tailwind styles are applied correctly. Test that shadcn/ui components can be imported and used.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Next.js Project with TypeScript and Tailwind CSS",
            "description": "Initialize a new Next.js project with TypeScript and Tailwind CSS using the create-next-app command.",
            "dependencies": [],
            "details": "Run the command: `npx create-next-app@latest chatbot-app --typescript --tailwind --eslint --app`. This will create a new Next.js project with App Router, TypeScript, Tailwind CSS, and ESLint configurations. Verify the installation by navigating to the project directory and checking that all necessary files are created.",
            "status": "done",
            "testStrategy": "Run `npm run dev` to start the development server and verify that the application loads without errors. Check that the default Next.js page appears with Tailwind styles applied."
          },
          {
            "id": 2,
            "title": "Configure TypeScript with Strict Mode",
            "description": "Update the TypeScript configuration to enable strict mode and other recommended settings.",
            "dependencies": [],
            "details": "Open the tsconfig.json file and update the compilerOptions to include strict mode, consistent casing enforcement, and other recommended settings. Ensure the configuration includes: `\"strict\": true`, `\"forceConsistentCasingInFileNames\": true`, `\"esModuleInterop\": true`, and `\"skipLibCheck\": true`.",
            "status": "done",
            "testStrategy": "Run `npx tsc --noEmit` to verify that TypeScript compilation works without errors. Test by intentionally introducing a type error and confirming that TypeScript catches it."
          },
          {
            "id": 3,
            "title": "Install and Configure shadcn/ui",
            "description": "Set up the shadcn/ui component library for consistent UI elements throughout the application.",
            "dependencies": [],
            "details": "Run `npx shadcn-ui@latest init` to initialize shadcn/ui. Follow the CLI prompts to configure the library according to project needs. This will set up the necessary configuration files and dependencies for shadcn/ui components. After initialization, install a test component like Button with `npx shadcn-ui@latest add button` to verify the setup.",
            "status": "done",
            "testStrategy": "Import and render a shadcn/ui component (like Button) in the main page. Verify that it displays correctly with proper styling and functionality."
          },
          {
            "id": 4,
            "title": "Set Up Project Folder Structure",
            "description": "Create the recommended folder structure following Next.js App Router conventions.",
            "dependencies": [],
            "details": "Create the following directory structure: app/ (for routes), components/ (for UI components), lib/ (for utilities), types/ (for TypeScript types), and public/ (for static assets). Within the app directory, set up the initial page.tsx file. Create placeholder files in each directory to ensure they're tracked by git.",
            "status": "done",
            "testStrategy": "Verify that all directories are created correctly. Test the folder structure by adding a simple component in the components directory and importing it into the main page."
          },
          {
            "id": 5,
            "title": "Configure ESLint and Prettier",
            "description": "Set up ESLint and Prettier for code quality and consistent formatting.",
            "dependencies": [],
            "details": "Install Prettier with `npm install --save-dev prettier eslint-config-prettier`. Create a .prettierrc file with project formatting rules. Update the .eslintrc.json file to extend the Prettier configuration. Add scripts to package.json for linting and formatting: `\"lint\": \"next lint\"` and `\"format\": \"prettier --write .\"`. Create a .vscode/settings.json file to enable format-on-save.",
            "status": "done",
            "testStrategy": "Run `npm run lint` to verify that ESLint runs without errors. Run `npm run format` to check that Prettier formats files correctly. Make an intentional linting error and verify that ESLint catches it."
          }
        ]
      },
      {
        "id": 2,
        "title": "Set Up Supabase Local Development Environment",
        "description": "Configure Supabase CLI and set up a local Supabase instance using Docker for development purposes.",
        "details": "1. Install Supabase CLI:\n```bash\nnpm install -g supabase\n```\n2. Initialize Supabase project:\n```bash\nsupabase init\n```\n3. Start local Supabase instance with Docker:\n```bash\nsupabase start\n```\n4. Create .env.local file with Supabase configuration:\n```\nNEXT_PUBLIC_SUPABASE_URL=http://localhost:54321\nNEXT_PUBLIC_SUPABASE_ANON_KEY=<your-local-anon-key>\nSUPABASE_SERVICE_ROLE_KEY=<your-local-service-role-key>\n```\n5. Set up Supabase client in lib/supabase.ts:\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```",
        "testStrategy": "Verify Supabase setup by running a simple query to the local database. Confirm that the Supabase dashboard is accessible at http://localhost:54323. Test connection by creating a simple table and inserting data through the client.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Database Schema and Migrations",
        "description": "Define and implement the database schema for messages and chats tables in Supabase as specified in the PRD.",
        "details": "1. Create SQL migration file for the database schema:\n```sql\n-- Create chats table\nCREATE TABLE chats (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  title TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create message_type enum\nCREATE TYPE message_type AS ENUM ('text', 'image');\n\n-- Create role enum\nCREATE TYPE message_role AS ENUM ('user', 'assistant');\n\n-- Create messages table\nCREATE TABLE messages (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  chat_id UUID REFERENCES chats(id) ON DELETE CASCADE,\n  content TEXT,\n  role message_role,\n  message_type message_type,\n  image_url TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create indexes\nCREATE INDEX idx_messages_chat_id ON messages(chat_id);\n```\n2. Apply migration using Supabase CLI:\n```bash\nsupabase migration new create_tables\n# Copy SQL into the created migration file\nsupabase db reset\n```\n3. Create TypeScript types for database schema in types/database.ts:\n```typescript\nexport type Chat = {\n  id: string;\n  title: string | null;\n  created_at: string;\n  updated_at: string;\n};\n\nexport type Message = {\n  id: string;\n  chat_id: string;\n  content: string;\n  role: 'user' | 'assistant';\n  message_type: 'text' | 'image';\n  image_url: string | null;\n  created_at: string;\n};\n```",
        "testStrategy": "Verify schema creation by querying the database structure. Test foreign key constraints by attempting to create messages with non-existent chat_ids. Validate enum constraints by trying to insert invalid role or message_type values. Confirm indexes are created properly.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Basic Chat UI Components",
        "description": "Create the core UI components for the chat interface, including message bubbles, input field, and chat container.",
        "details": "1. Create message bubble components in components/ui/message-bubble.tsx:\n```typescript\nimport { cn } from '@/lib/utils';\nimport { Message } from '@/types/database';\nimport Image from 'next/image';\n\ninterface MessageBubbleProps {\n  message: Message;\n}\n\nexport function MessageBubble({ message }: MessageBubbleProps) {\n  const isUser = message.role === 'user';\n  \n  return (\n    <div className={cn(\n      'flex w-full',\n      isUser ? 'justify-end' : 'justify-start'\n    )}>\n      <div className={cn(\n        'max-w-[80%] rounded-lg p-4',\n        isUser ? 'bg-primary text-primary-foreground' : 'bg-muted'\n      )}>\n        {message.message_type === 'text' ? (\n          <p className=\"whitespace-pre-wrap\">{message.content}</p>\n        ) : (\n          <div className=\"space-y-2\">\n            <p className=\"whitespace-pre-wrap\">{message.content}</p>\n            {message.image_url && (\n              <div className=\"relative aspect-square w-full max-w-sm overflow-hidden rounded-md\">\n                <Image \n                  src={message.image_url} \n                  alt=\"Generated image\"\n                  fill\n                  className=\"object-cover\"\n                />\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n2. Create chat input component in components/chat-input.tsx:\n```typescript\nimport { Button } from '@/components/ui/button';\nimport { Textarea } from '@/components/ui/textarea';\nimport { useState } from 'react';\n\ninterface ChatInputProps {\n  onSendMessage: (content: string) => void;\n  isImageMode: boolean;\n  disabled?: boolean;\n}\n\nexport function ChatInput({ onSendMessage, isImageMode, disabled }: ChatInputProps) {\n  const [input, setInput] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (input.trim()) {\n      onSendMessage(input);\n      setInput('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex w-full items-end gap-2\">\n      <Textarea\n        value={input}\n        onChange={(e) => setInput(e.target.value)}\n        placeholder={isImageMode ? \"Describe the image you want to generate...\" : \"Type your message...\"}\n        className=\"min-h-[60px] flex-1 resize-none\"\n        disabled={disabled}\n        onKeyDown={(e) => {\n          if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSubmit(e);\n          }\n        }}\n      />\n      <Button type=\"submit\" disabled={disabled || !input.trim()}>\n        Send\n      </Button>\n    </form>\n  );\n}\n```\n3. Create chat container in components/chat-container.tsx:\n```typescript\nimport { Message } from '@/types/database';\nimport { MessageBubble } from '@/components/ui/message-bubble';\nimport { useRef, useEffect } from 'react';\n\ninterface ChatContainerProps {\n  messages: Message[];\n  isLoading?: boolean;\n}\n\nexport function ChatContainer({ messages, isLoading }: ChatContainerProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTop = containerRef.current.scrollHeight;\n    }\n  }, [messages]);\n\n  return (\n    <div \n      ref={containerRef}\n      className=\"flex flex-1 flex-col gap-4 overflow-y-auto p-4\"\n    >\n      {messages.length === 0 ? (\n        <div className=\"flex h-full items-center justify-center\">\n          <p className=\"text-muted-foreground\">Start a conversation...</p>\n        </div>\n      ) : (\n        messages.map((message) => (\n          <MessageBubble key={message.id} message={message} />\n        ))\n      )}\n      {isLoading && (\n        <div className=\"flex justify-start\">\n          <div className=\"bg-muted rounded-lg p-4\">\n            <div className=\"flex gap-1\">\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current\"></div>\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current delay-75\"></div>\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current delay-150\"></div>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "Test UI components by rendering them with mock data and verifying their appearance. Check responsive behavior on different screen sizes. Verify that the chat input correctly handles user input and submits messages. Test that the message bubbles correctly display different message types (text vs image).",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Chat Layout and Mode Toggle",
        "description": "Create the main chat layout with header, sidebar, and toggle between text and image generation modes.",
        "details": "1. Create mode toggle component in components/mode-toggle.tsx:\n```typescript\nimport { Button } from '@/components/ui/button';\nimport { MessageSquare, Image as ImageIcon } from 'lucide-react';\n\ninterface ModeToggleProps {\n  isImageMode: boolean;\n  onToggle: () => void;\n  disabled?: boolean;\n}\n\nexport function ModeToggle({ isImageMode, onToggle, disabled }: ModeToggleProps) {\n  return (\n    <div className=\"flex items-center gap-2\">\n      <span className=\"text-sm font-medium\">Mode:</span>\n      <Button \n        variant=\"outline\" \n        size=\"sm\" \n        onClick={onToggle} \n        disabled={disabled}\n        className=\"flex items-center gap-2\"\n      >\n        {isImageMode ? (\n          <>\n            <ImageIcon className=\"h-4 w-4\" />\n            <span>Image</span>\n          </>\n        ) : (\n          <>\n            <MessageSquare className=\"h-4 w-4\" />\n            <span>Text</span>\n          </>\n        )}\n      </Button>\n    </div>\n  );\n}\n```\n2. Create new chat button in components/new-chat-button.tsx:\n```typescript\nimport { Button } from '@/components/ui/button';\nimport { PlusCircle } from 'lucide-react';\n\ninterface NewChatButtonProps {\n  onClick: () => void;\n  disabled?: boolean;\n}\n\nexport function NewChatButton({ onClick, disabled }: NewChatButtonProps) {\n  return (\n    <Button \n      variant=\"outline\" \n      onClick={onClick} \n      disabled={disabled}\n      className=\"flex w-full items-center gap-2\"\n    >\n      <PlusCircle className=\"h-4 w-4\" />\n      <span>New Chat</span>\n    </Button>\n  );\n}\n```\n3. Create main chat layout in app/page.tsx:\n```typescript\n'use client';\n\nimport { useState } from 'react';\nimport { ChatContainer } from '@/components/chat-container';\nimport { ChatInput } from '@/components/chat-input';\nimport { ModeToggle } from '@/components/mode-toggle';\nimport { NewChatButton } from '@/components/new-chat-button';\nimport { Message } from '@/types/database';\n\nexport default function Home() {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isImageMode, setIsImageMode] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleSendMessage = async (content: string) => {\n    // Will be implemented in later tasks\n    console.log('Sending message:', content, 'Mode:', isImageMode ? 'image' : 'text');\n  };\n\n  const handleNewChat = () => {\n    // Will be implemented in later tasks\n    setMessages([]);\n  };\n\n  return (\n    <div className=\"flex h-screen flex-col\">\n      <header className=\"border-b p-4\">\n        <div className=\"mx-auto flex max-w-6xl items-center justify-between\">\n          <h1 className=\"text-xl font-bold\">AI Chatbot</h1>\n          <ModeToggle \n            isImageMode={isImageMode} \n            onToggle={() => setIsImageMode(!isImageMode)} \n            disabled={isLoading} \n          />\n        </div>\n      </header>\n      <main className=\"flex flex-1 overflow-hidden\">\n        <div className=\"hidden w-64 border-r p-4 md:block\">\n          <NewChatButton onClick={handleNewChat} disabled={isLoading} />\n          {/* Chat history will be added in future tasks */}\n        </div>\n        <div className=\"flex flex-1 flex-col\">\n          <ChatContainer messages={messages} isLoading={isLoading} />\n          <div className=\"border-t p-4\">\n            <div className=\"mx-auto max-w-3xl\">\n              <ChatInput \n                onSendMessage={handleSendMessage} \n                isImageMode={isImageMode} \n                disabled={isLoading} \n              />\n            </div>\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n}\n```",
        "testStrategy": "Test the layout by verifying that all components render correctly and are positioned properly. Check that the mode toggle correctly switches between text and image modes. Verify that the new chat button clears the current conversation. Test responsive behavior on different screen sizes, especially the sidebar hiding on mobile.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement OpenAI API Integration for Text Generation",
        "description": "Set up the OpenAI API client and implement the backend Edge Function for text-based chat using GPT-4.1-nano-2025-04-14.",
        "details": "1. Install OpenAI SDK:\n```bash\nnpm install openai\n```\n2. Create OpenAI client utility in lib/openai.ts:\n```typescript\nimport OpenAI from 'openai';\n\nexport const openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n```\n3. Create Edge Function for chat in app/api/chat/route.ts:\n```typescript\nimport { openai } from '@/lib/openai';\nimport { supabase } from '@/lib/supabase';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { messages, chatId } = await req.json();\n    \n    // Validate request\n    if (!messages || !Array.isArray(messages)) {\n      return NextResponse.json({ error: 'Invalid messages format' }, { status: 400 });\n    }\n    \n    // Create chat if chatId is not provided\n    let currentChatId = chatId;\n    if (!currentChatId) {\n      const { data: chat, error: chatError } = await supabase\n        .from('chats')\n        .insert({})\n        .select()\n        .single();\n        \n      if (chatError) {\n        console.error('Error creating chat:', chatError);\n        return NextResponse.json({ error: 'Failed to create chat' }, { status: 500 });\n      }\n      \n      currentChatId = chat.id;\n    }\n    \n    // Store user message\n    const userMessage = messages[messages.length - 1];\n    const { error: messageError } = await supabase\n      .from('messages')\n      .insert({\n        chat_id: currentChatId,\n        content: userMessage.content,\n        role: 'user',\n        message_type: 'text'\n      });\n      \n    if (messageError) {\n      console.error('Error storing user message:', messageError);\n    }\n    \n    // Create stream\n    const stream = await openai.chat.completions.create({\n      model: 'gpt-4.1-nano-2025-04-14',\n      messages: messages.map(m => ({ role: m.role, content: m.content })),\n      stream: true,\n    });\n    \n    // Return stream to client\n    const encoder = new TextEncoder();\n    const readable = new ReadableStream({\n      async start(controller) {\n        let fullResponse = '';\n        \n        try {\n          for await (const chunk of stream) {\n            const content = chunk.choices[0]?.delta?.content || '';\n            if (content) {\n              controller.enqueue(encoder.encode(content));\n              fullResponse += content;\n            }\n          }\n          \n          // Store assistant message after stream completes\n          const { error: assistantMessageError } = await supabase\n            .from('messages')\n            .insert({\n              chat_id: currentChatId,\n              content: fullResponse,\n              role: 'assistant',\n              message_type: 'text'\n            });\n            \n          if (assistantMessageError) {\n            console.error('Error storing assistant message:', assistantMessageError);\n          }\n          \n          controller.close();\n        } catch (error) {\n          console.error('Stream error:', error);\n          controller.error(error);\n        }\n      }\n    });\n    \n    return new NextResponse(readable, {\n      headers: {\n        'Content-Type': 'text/plain',\n        'X-Chat-Id': currentChatId\n      }\n    });\n  } catch (error) {\n    console.error('Chat API error:', error);\n    return NextResponse.json(\n      { error: 'An error occurred while processing your request' },\n      { status: 500 }\n    );\n  }\n}\n```\n4. Add environment variables for OpenAI API in .env.local:\n```\nOPENAI_API_KEY=your-openai-api-key\n```",
        "testStrategy": "Test the API endpoint by sending sample chat messages and verifying the streaming response. Check that messages are correctly stored in the database. Test error handling by simulating API failures. Verify that the chat ID is correctly returned in headers for new conversations.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Frontend Chat Logic with Streaming",
        "description": "Connect the frontend chat UI to the backend API, implementing real-time streaming of responses and message state management.",
        "details": "1. Create chat service in lib/chat-service.ts:\n```typescript\nimport { Message } from '@/types/database';\n\nexport async function sendChatMessage(content: string, chatId?: string): Promise<{\n  chatId: string;\n  responseStream: ReadableStream;\n}> {\n  const messages = [\n    { role: 'user', content }\n  ];\n  \n  const response = await fetch('/api/chat', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      messages,\n      chatId,\n    }),\n  });\n  \n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to send message');\n  }\n  \n  const chatIdFromHeader = response.headers.get('X-Chat-Id');\n  \n  if (!chatIdFromHeader) {\n    throw new Error('No chat ID returned from server');\n  }\n  \n  return {\n    chatId: chatIdFromHeader,\n    responseStream: response.body!,\n  };\n}\n\nexport async function fetchChatMessages(chatId: string): Promise<Message[]> {\n  const { data, error } = await supabase\n    .from('messages')\n    .select('*')\n    .eq('chat_id', chatId)\n    .order('created_at', { ascending: true });\n    \n  if (error) {\n    console.error('Error fetching messages:', error);\n    throw new Error('Failed to fetch messages');\n  }\n  \n  return data;\n}\n```\n2. Update app/page.tsx to use the chat service:\n```typescript\n'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { ChatContainer } from '@/components/chat-container';\nimport { ChatInput } from '@/components/chat-input';\nimport { ModeToggle } from '@/components/mode-toggle';\nimport { NewChatButton } from '@/components/new-chat-button';\nimport { Message } from '@/types/database';\nimport { sendChatMessage, fetchChatMessages } from '@/lib/chat-service';\nimport { v4 as uuidv4 } from 'uuid';\nimport { useToast } from '@/components/ui/use-toast';\n\nexport default function Home() {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isImageMode, setIsImageMode] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [currentChatId, setCurrentChatId] = useState<string | null>(null);\n  const { toast } = useToast();\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const handleSendMessage = async (content: string) => {\n    try {\n      setIsLoading(true);\n      \n      // Add user message to UI immediately\n      const userMessage: Message = {\n        id: uuidv4(),\n        chat_id: currentChatId || '',\n        content,\n        role: 'user',\n        message_type: 'text',\n        image_url: null,\n        created_at: new Date().toISOString(),\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      if (isImageMode) {\n        // Image generation will be implemented in a later task\n        return;\n      }\n      \n      // Create abort controller for the stream\n      abortControllerRef.current = new AbortController();\n      \n      // Send message to API\n      const { chatId, responseStream } = await sendChatMessage(content, currentChatId || undefined);\n      \n      if (!currentChatId) {\n        setCurrentChatId(chatId);\n      }\n      \n      // Create placeholder for streaming response\n      const assistantMessage: Message = {\n        id: uuidv4(),\n        chat_id: chatId,\n        content: '',\n        role: 'assistant',\n        message_type: 'text',\n        image_url: null,\n        created_at: new Date().toISOString(),\n      };\n      \n      setMessages(prev => [...prev, assistantMessage]);\n      \n      // Process the stream\n      const reader = responseStream.getReader();\n      const decoder = new TextDecoder();\n      \n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) {\n          break;\n        }\n        \n        const text = decoder.decode(value);\n        \n        // Update the assistant message with new content\n        setMessages(prev => {\n          const updated = [...prev];\n          const lastIndex = updated.length - 1;\n          updated[lastIndex] = {\n            ...updated[lastIndex],\n            content: updated[lastIndex].content + text,\n          };\n          return updated;\n        });\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      toast({\n        title: 'Error',\n        description: error instanceof Error ? error.message : 'Failed to send message',\n        variant: 'destructive',\n      });\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  };\n\n  const handleNewChat = () => {\n    // Cancel any ongoing requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    \n    setMessages([]);\n    setCurrentChatId(null);\n    setIsLoading(false);\n  };\n\n  return (\n    <div className=\"flex h-screen flex-col\">\n      {/* Header and layout code from previous task */}\n      {/* ... */}\n    </div>\n  );\n}\n```\n3. Install uuid for generating temporary IDs:\n```bash\nnpm install uuid\nnpm install --save-dev @types/uuid\n```",
        "testStrategy": "Test the chat functionality by sending messages and verifying that responses stream in real-time. Check that the UI updates correctly as new tokens arrive. Test error handling by simulating network failures. Verify that the new chat button correctly resets the conversation state.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement OpenAI API Integration for Image Generation",
        "description": "Create the backend Edge Function for image generation using OpenAI's gpt-image-1 model.",
        "details": "1. Create Edge Function for image generation in app/api/generate-image/route.ts:\n```typescript\nimport { openai } from '@/lib/openai';\nimport { supabase } from '@/lib/supabase';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { prompt, chatId } = await req.json();\n    \n    // Validate request\n    if (!prompt || typeof prompt !== 'string') {\n      return NextResponse.json({ error: 'Invalid prompt' }, { status: 400 });\n    }\n    \n    if (!chatId) {\n      return NextResponse.json({ error: 'Chat ID is required' }, { status: 400 });\n    }\n    \n    // Store user message\n    const { error: messageError } = await supabase\n      .from('messages')\n      .insert({\n        chat_id: chatId,\n        content: prompt,\n        role: 'user',\n        message_type: 'image'\n      });\n      \n    if (messageError) {\n      console.error('Error storing user message:', messageError);\n    }\n    \n    // Generate image\n    const response = await openai.images.generate({\n      model: 'gpt-image-1',\n      prompt,\n      n: 1,\n      size: '1024x1024',\n    });\n    \n    const imageUrl = response.data[0]?.url;\n    \n    if (!imageUrl) {\n      throw new Error('No image generated');\n    }\n    \n    // Store assistant message with image\n    const { error: assistantMessageError } = await supabase\n      .from('messages')\n      .insert({\n        chat_id: chatId,\n        content: `Image generated from prompt: \"${prompt}\"`,\n        role: 'assistant',\n        message_type: 'image',\n        image_url: imageUrl\n      });\n      \n    if (assistantMessageError) {\n      console.error('Error storing assistant message:', assistantMessageError);\n    }\n    \n    return NextResponse.json({ imageUrl });\n  } catch (error) {\n    console.error('Image generation API error:', error);\n    return NextResponse.json(\n      { error: 'An error occurred while generating the image' },\n      { status: 500 }\n    );\n  }\n}\n```",
        "testStrategy": "Test the image generation endpoint by sending sample prompts and verifying that images are generated correctly. Check that messages are properly stored in the database with the correct message_type. Test error handling by simulating API failures and invalid inputs.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Frontend Image Generation Integration",
        "description": "Connect the frontend image generation mode to the backend API and implement the UI for displaying generated images.",
        "details": "1. Create image generation service in lib/image-service.ts:\n```typescript\nexport async function generateImage(prompt: string, chatId: string): Promise<string> {\n  const response = await fetch('/api/generate-image', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      prompt,\n      chatId,\n    }),\n  });\n  \n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to generate image');\n  }\n  \n  const { imageUrl } = await response.json();\n  \n  if (!imageUrl) {\n    throw new Error('No image URL returned');\n  }\n  \n  return imageUrl;\n}\n```\n2. Update app/page.tsx to handle image generation:\n```typescript\n// Add to existing imports\nimport { generateImage } from '@/lib/image-service';\n\n// Update handleSendMessage function to handle image mode\nconst handleSendMessage = async (content: string) => {\n  try {\n    setIsLoading(true);\n    \n    // Add user message to UI immediately\n    const userMessage: Message = {\n      id: uuidv4(),\n      chat_id: currentChatId || '',\n      content,\n      role: 'user',\n      message_type: isImageMode ? 'image' : 'text',\n      image_url: null,\n      created_at: new Date().toISOString(),\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    \n    // Create a chat if we don't have one yet\n    if (!currentChatId) {\n      const { data: chat, error } = await supabase\n        .from('chats')\n        .insert({})\n        .select()\n        .single();\n        \n      if (error) {\n        throw new Error('Failed to create chat');\n      }\n      \n      setCurrentChatId(chat.id);\n    }\n    \n    if (isImageMode) {\n      // Handle image generation\n      const assistantMessage: Message = {\n        id: uuidv4(),\n        chat_id: currentChatId!,\n        content: `Generating image from prompt: \"${content}\"...`,\n        role: 'assistant',\n        message_type: 'image',\n        image_url: null,\n        created_at: new Date().toISOString(),\n      };\n      \n      setMessages(prev => [...prev, assistantMessage]);\n      \n      const imageUrl = await generateImage(content, currentChatId!);\n      \n      // Update the assistant message with the image URL\n      setMessages(prev => {\n        const updated = [...prev];\n        const lastIndex = updated.length - 1;\n        updated[lastIndex] = {\n          ...updated[lastIndex],\n          content: `Image generated from prompt: \"${content}\"`,\n          image_url: imageUrl,\n        };\n        return updated;\n      });\n    } else {\n      // Text chat logic (from previous task)\n      // ...\n    }\n  } catch (error) {\n    console.error('Error:', error);\n    toast({\n      title: 'Error',\n      description: error instanceof Error ? error.message : 'An error occurred',\n      variant: 'destructive',\n    });\n  } finally {\n    setIsLoading(false);\n  }\n};\n```",
        "testStrategy": "Test image generation by toggling to image mode and submitting prompts. Verify that images are displayed correctly in the chat interface. Test error handling by simulating API failures. Check that the loading state is properly managed during image generation.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Chat History and New Chat Functionality",
        "description": "Implement the ability to view chat history, start new conversations, and switch between existing chats.",
        "details": "1. Create chat history service in lib/chat-history-service.ts:\n```typescript\nimport { supabase } from '@/lib/supabase';\nimport { Chat } from '@/types/database';\n\nexport async function fetchChatHistory(): Promise<Chat[]> {\n  const { data, error } = await supabase\n    .from('chats')\n    .select('*')\n    .order('updated_at', { ascending: false });\n    \n  if (error) {\n    console.error('Error fetching chat history:', error);\n    throw new Error('Failed to fetch chat history');\n  }\n  \n  return data;\n}\n\nexport async function createNewChat(): Promise<Chat> {\n  const { data, error } = await supabase\n    .from('chats')\n    .insert({})\n    .select()\n    .single();\n    \n  if (error) {\n    console.error('Error creating new chat:', error);\n    throw new Error('Failed to create new chat');\n  }\n  \n  return data;\n}\n\nexport async function updateChatTitle(chatId: string, title: string): Promise<void> {\n  const { error } = await supabase\n    .from('chats')\n    .update({ title, updated_at: new Date().toISOString() })\n    .eq('id', chatId);\n    \n  if (error) {\n    console.error('Error updating chat title:', error);\n    throw new Error('Failed to update chat title');\n  }\n}\n```\n2. Create chat history component in components/chat-history.tsx:\n```typescript\nimport { Chat } from '@/types/database';\nimport { Button } from '@/components/ui/button';\nimport { MessageSquare } from 'lucide-react';\n\ninterface ChatHistoryProps {\n  chats: Chat[];\n  currentChatId: string | null;\n  onSelectChat: (chatId: string) => void;\n}\n\nexport function ChatHistory({ chats, currentChatId, onSelectChat }: ChatHistoryProps) {\n  return (\n    <div className=\"mt-4 space-y-2\">\n      <h2 className=\"text-sm font-medium text-muted-foreground\">Chat History</h2>\n      {chats.length === 0 ? (\n        <p className=\"text-sm text-muted-foreground\">No previous chats</p>\n      ) : (\n        <ul className=\"space-y-1\">\n          {chats.map(chat => (\n            <li key={chat.id}>\n              <Button\n                variant={chat.id === currentChatId ? 'secondary' : 'ghost'}\n                className=\"w-full justify-start truncate text-left\"\n                onClick={() => onSelectChat(chat.id)}\n              >\n                <MessageSquare className=\"mr-2 h-4 w-4\" />\n                <span className=\"truncate\">\n                  {chat.title || 'New Chat'}\n                </span>\n              </Button>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```\n3. Update app/page.tsx to include chat history:\n```typescript\n// Add to existing imports\nimport { ChatHistory } from '@/components/chat-history';\nimport { fetchChatHistory, createNewChat } from '@/lib/chat-history-service';\n\n// Add state for chat history\nconst [chats, setChats] = useState<Chat[]>([]);\n\n// Add useEffect to fetch chat history\nuseEffect(() => {\n  const loadChatHistory = async () => {\n    try {\n      const history = await fetchChatHistory();\n      setChats(history);\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n      toast({\n        title: 'Error',\n        description: 'Failed to load chat history',\n        variant: 'destructive',\n      });\n    }\n  };\n  \n  loadChatHistory();\n}, [toast]);\n\n// Update handleNewChat function\nconst handleNewChat = async () => {\n  try {\n    // Cancel any ongoing requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    \n    setMessages([]);\n    setCurrentChatId(null);\n    setIsLoading(false);\n    \n    // Create a new chat in the database\n    const newChat = await createNewChat();\n    setCurrentChatId(newChat.id);\n    \n    // Update chat history\n    setChats(prev => [newChat, ...prev]);\n  } catch (error) {\n    console.error('Error creating new chat:', error);\n    toast({\n      title: 'Error',\n      description: 'Failed to create new chat',\n      variant: 'destructive',\n    });\n  }\n};\n\n// Add function to handle chat selection\nconst handleSelectChat = async (chatId: string) => {\n  try {\n    // Cancel any ongoing requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    \n    setIsLoading(true);\n    setCurrentChatId(chatId);\n    \n    // Fetch messages for the selected chat\n    const chatMessages = await fetchChatMessages(chatId);\n    setMessages(chatMessages);\n  } catch (error) {\n    console.error('Error selecting chat:', error);\n    toast({\n      title: 'Error',\n      description: 'Failed to load chat messages',\n      variant: 'destructive',\n    });\n  } finally {\n    setIsLoading(false);\n  }\n};\n\n// Update sidebar in the JSX\n<div className=\"hidden w-64 border-r p-4 md:block\">\n  <NewChatButton onClick={handleNewChat} disabled={isLoading} />\n  <ChatHistory \n    chats={chats} \n    currentChatId={currentChatId} \n    onSelectChat={handleSelectChat} \n  />\n</div>\n```",
        "testStrategy": "Test chat history functionality by creating multiple chats and verifying that they appear in the sidebar. Check that selecting a chat loads its messages correctly. Test the new chat button to ensure it creates a new conversation. Verify that chat titles are displayed correctly and that the current chat is highlighted.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Comprehensive Error Handling",
        "description": "Implement robust error handling throughout the application, with user-friendly error messages and proper error logging.",
        "details": "1. Create error handling utility in lib/error-handler.ts:\n```typescript\ntype ErrorWithMessage = {\n  message: string;\n};\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof (error as Record<string, unknown>).message === 'string'\n  );\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n  if (isErrorWithMessage(maybeError)) return maybeError;\n  \n  try {\n    return new Error(JSON.stringify(maybeError));\n  } catch {\n    // fallback in case there's an error stringifying the maybeError\n    return new Error(String(maybeError));\n  }\n}\n\nexport function getErrorMessage(error: unknown): string {\n  return toErrorWithMessage(error).message;\n}\n\nexport function logError(error: unknown, context?: string): void {\n  const message = getErrorMessage(error);\n  console.error(`${context ? `[${context}] ` : ''}Error: ${message}`);\n  \n  // In a production app, you might want to send this to a logging service\n  // like Sentry or LogRocket\n}\n\nexport function getUserFriendlyErrorMessage(error: unknown): string {\n  const message = getErrorMessage(error);\n  \n  // Map specific error messages to user-friendly versions\n  if (message.includes('OpenAI API')) {\n    return 'The AI service is currently unavailable. Please try again later.';\n  }\n  \n  if (message.includes('network')) {\n    return 'Network error. Please check your internet connection and try again.';\n  }\n  \n  if (message.includes('timeout')) {\n    return 'The request timed out. Please try again.';\n  }\n  \n  if (message.includes('rate limit')) {\n    return 'Too many requests. Please wait a moment and try again.';\n  }\n  \n  // Default message for unknown errors\n  return 'Something went wrong. Please try again later.';\n}\n```\n2. Create error boundary component in components/error-boundary.tsx:\n```typescript\n'use client';\n\nimport { Button } from '@/components/ui/button';\nimport { getUserFriendlyErrorMessage, logError } from '@/lib/error-handler';\nimport { useEffect, useState } from 'react';\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nexport function ErrorBoundary({ children }: ErrorBoundaryProps) {\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    const handleError = (event: ErrorEvent) => {\n      logError(event.error, 'Window Error');\n      setError(event.error);\n      event.preventDefault();\n    };\n\n    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n      logError(event.reason, 'Unhandled Promise Rejection');\n      setError(event.reason instanceof Error ? event.reason : new Error(String(event.reason)));\n      event.preventDefault();\n    };\n\n    window.addEventListener('error', handleError);\n    window.addEventListener('unhandledrejection', handleUnhandledRejection);\n\n    return () => {\n      window.removeEventListener('error', handleError);\n      window.removeEventListener('unhandledrejection', handleUnhandledRejection);\n    };\n  }, []);\n\n  if (error) {\n    return (\n      <div className=\"flex h-full flex-col items-center justify-center p-4 text-center\">\n        <h2 className=\"mb-2 text-xl font-bold\">Something went wrong</h2>\n        <p className=\"mb-4 text-muted-foreground\">\n          {getUserFriendlyErrorMessage(error)}\n        </p>\n        <Button onClick={() => window.location.reload()}>Refresh the page</Button>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}\n```\n3. Update app/layout.tsx to include the error boundary:\n```typescript\nimport { ErrorBoundary } from '@/components/error-boundary';\nimport { Toaster } from '@/components/ui/toaster';\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <ErrorBoundary>\n          {children}\n        </ErrorBoundary>\n        <Toaster />\n      </body>\n    </html>\n  );\n}\n```\n4. Update API error handling in route handlers:\n```typescript\n// In app/api/chat/route.ts and app/api/generate-image/route.ts\nimport { logError } from '@/lib/error-handler';\n\n// Replace console.error calls with logError\nlogError(error, 'Chat API');\n```",
        "testStrategy": "Test error handling by simulating various error conditions: network failures, API errors, and unexpected exceptions. Verify that user-friendly error messages are displayed in the UI. Check that errors are properly logged to the console. Test the error boundary by intentionally throwing errors in different parts of the application.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Mobile Responsiveness and Accessibility",
        "description": "Enhance the application with mobile-responsive design and accessibility features to ensure a good user experience across all devices.",
        "details": "1. Create mobile navigation component in components/mobile-nav.tsx:\n```typescript\nimport { Button } from '@/components/ui/button';\nimport { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';\nimport { Menu } from 'lucide-react';\nimport { useState } from 'react';\n\ninterface MobileNavProps {\n  children: React.ReactNode;\n}\n\nexport function MobileNav({ children }: MobileNavProps) {\n  const [open, setOpen] = useState(false);\n\n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button variant=\"ghost\" size=\"icon\" className=\"md:hidden\">\n          <Menu className=\"h-5 w-5\" />\n          <span className=\"sr-only\">Toggle menu</span>\n        </Button>\n      </SheetTrigger>\n      <SheetContent side=\"left\" className=\"w-64 p-0\">\n        <div className=\"p-4\">\n          {children}\n        </div>\n      </SheetContent>\n    </Sheet>\n  );\n}\n```\n2. Update app/page.tsx to include mobile navigation:\n```typescript\n// Add to existing imports\nimport { MobileNav } from '@/components/mobile-nav';\n\n// Update header in the JSX\n<header className=\"border-b p-4\">\n  <div className=\"mx-auto flex max-w-6xl items-center justify-between\">\n    <div className=\"flex items-center gap-2\">\n      <MobileNav>\n        <NewChatButton onClick={handleNewChat} disabled={isLoading} />\n        <ChatHistory \n          chats={chats} \n          currentChatId={currentChatId} \n          onSelectChat={handleSelectChat} \n        />\n      </MobileNav>\n      <h1 className=\"text-xl font-bold\">AI Chatbot</h1>\n    </div>\n    <ModeToggle \n      isImageMode={isImageMode} \n      onToggle={() => setIsImageMode(!isImageMode)} \n      disabled={isLoading} \n    />\n  </div>\n</header>\n```\n3. Add accessibility enhancements to components/chat-input.tsx:\n```typescript\n// Update ChatInput component\nexport function ChatInput({ onSendMessage, isImageMode, disabled }: ChatInputProps) {\n  const [input, setInput] = useState('');\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (input.trim()) {\n      onSendMessage(input);\n      setInput('');\n      // Focus back on input after sending\n      setTimeout(() => inputRef.current?.focus(), 0);\n    }\n  };\n\n  return (\n    <form \n      onSubmit={handleSubmit} \n      className=\"flex w-full items-end gap-2\"\n      aria-label=\"Chat message form\"\n    >\n      <Textarea\n        ref={inputRef}\n        value={input}\n        onChange={(e) => setInput(e.target.value)}\n        placeholder={isImageMode ? \"Describe the image you want to generate...\" : \"Type your message...\"}\n        className=\"min-h-[60px] flex-1 resize-none\"\n        disabled={disabled}\n        aria-label={isImageMode ? \"Image prompt input\" : \"Message input\"}\n        onKeyDown={(e) => {\n          if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSubmit(e);\n          }\n        }}\n      />\n      <Button \n        type=\"submit\" \n        disabled={disabled || !input.trim()}\n        aria-label=\"Send message\"\n      >\n        Send\n      </Button>\n    </form>\n  );\n}\n```\n4. Add responsive styles to components/chat-container.tsx:\n```typescript\n// Update ChatContainer component\nexport function ChatContainer({ messages, isLoading }: ChatContainerProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollTop = containerRef.current.scrollHeight;\n    }\n  }, [messages]);\n\n  return (\n    <div \n      ref={containerRef}\n      className=\"flex flex-1 flex-col gap-4 overflow-y-auto p-2 sm:p-4\"\n      aria-live=\"polite\"\n      aria-label=\"Chat messages\"\n    >\n      {messages.length === 0 ? (\n        <div className=\"flex h-full flex-col items-center justify-center p-4 text-center\">\n          <h2 className=\"text-xl font-bold\">Welcome to AI Chatbot</h2>\n          <p className=\"mt-2 text-muted-foreground\">\n            Start a conversation or generate an image using the input below.\n          </p>\n        </div>\n      ) : (\n        messages.map((message) => (\n          <div key={message.id}>\n            <MessageBubble message={message} />\n          </div>\n        ))\n      )}\n      {isLoading && (\n        <div className=\"flex justify-start\">\n          <div className=\"bg-muted rounded-lg p-4\">\n            <div className=\"flex gap-1\">\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current\"></div>\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current delay-75\"></div>\n              <div className=\"h-2 w-2 animate-bounce rounded-full bg-current delay-150\"></div>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n5. Add meta tags for responsive design in app/layout.tsx:\n```typescript\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" />\n        <meta name=\"description\" content=\"AI-powered chatbot with image generation capabilities\" />\n        <title>AI Chatbot</title>\n      </head>\n      <body>\n        <ErrorBoundary>\n          {children}\n        </ErrorBoundary>\n        <Toaster />\n      </body>\n    </html>\n  );\n}\n```",
        "testStrategy": "Test mobile responsiveness by viewing the application on different device sizes and verifying that the layout adapts correctly. Check that the mobile navigation works properly. Test accessibility by using keyboard navigation, screen readers, and accessibility audit tools. Verify that all interactive elements have appropriate ARIA attributes and that the application meets WCAG 2.1 AA standards.",
        "priority": "medium",
        "dependencies": [
          5,
          10
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-25T01:59:38.313Z",
      "updated": "2025-07-25T02:31:40.791Z",
      "description": "Tasks for master context"
    }
  }
}